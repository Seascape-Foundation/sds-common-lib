package message

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/ahmetson/datatype-lib/data_type/key_value"
	"github.com/google/uuid"
)

//
// RawRequest and RawReply are not shared as a json or yaml.
//

// RawRequest is the wrapper around zeromq message envelope.
type RawRequest struct {
	Uuid      string
	conId     string
	messages  []string
	trace     []*Stack
	publicKey string
}

type RawReply struct {
	Uuid     string
	conId    string
	messages []string
	trace    []*Stack
}

// RawMessage returns a message for parsing request and parsing reply.
func RawMessage() *Operations {
	return &Operations{
		Name:       "raw",
		NewReq:     NewRawReq,
		NewReply:   NewRawRep,
		EmptyReq:   NewEmptyRawReq,
		EmptyReply: NewEmptyRawReply,
	}
}

func NewEmptyRawReq() RequestInterface {
	return &RawRequest{}
}

func NewEmptyRawReply() ReplyInterface {
	return &RawReply{}
}

// NewRawReq from the zeromq rawReq.
func NewRawReq(messages []string) (RequestInterface, error) {
	if !MultiPart(messages) && !SyncReplierEnvelope(messages) {
		return nil, fmt.Errorf("not multipart or sync replier envelope")
	}

	contentOffset := 1
	contentEnd := len(messages)

	request := &RawRequest{
		trace: make([]*Stack, 0),
	}
	if MultiPart(messages) {
		request.conId = messages[0]
		contentOffset = 2
	}

	traceDelimiter := RawTraceIndex(messages)
	if traceDelimiter > -1 {
		contentEnd = traceDelimiter
	}

	request.messages = messages[contentOffset:contentEnd]
	if traceDelimiter > -1 {
		if len(messages[traceDelimiter+1:]) == 0 {
			return nil, fmt.Errorf("trace delimiter given but trace is empty")
		}

		var traces []*Stack
		err := json.Unmarshal([]byte(messages[len(messages)-1]), &traces)
		if err != nil {
			return nil, fmt.Errorf("json.Unmarshal('last_message_part'): %w", err)
		}
		request.trace = traces
	}

	return request, nil
}

func NewRawRep(messages []string) (ReplyInterface, error) {
	if !MultiPart(messages) && !SyncReplierEnvelope(messages) {
		return nil, fmt.Errorf("not multipart or sync replier envelope")
	}

	contentOffset := 1
	contentEnd := len(messages) - 1

	reply := &RawReply{
		trace: make([]*Stack, 0),
	}
	if MultiPart(messages) {
		reply.conId = messages[0]
		contentOffset = 2
	}

	traceDelimiter := RawTraceIndex(messages)
	if traceDelimiter > -1 {
		contentEnd = traceDelimiter
	}

	reply.messages = messages[contentOffset:contentEnd]
	if traceDelimiter > -1 {
		if len(messages[traceDelimiter+1:]) == 0 {
			return nil, fmt.Errorf("trace delimiter given but trace is empty")
		}

		var traces []*Stack
		err := json.Unmarshal([]byte(messages[len(messages)-1]), &traces)
		if err != nil {
			return nil, fmt.Errorf("json.Unmarshal('last_message_part'): %w", err)
		}
		reply.trace = traces
	}

	return reply, nil
}

func RawTraceIndex(messages []string) int {
	// contentOffset skips the first delimiter
	contentOffset := 0
	if MultiPart(messages) {
		contentOffset = 2
	} else if SyncReplierEnvelope(messages) {
		contentOffset = 1
	}

	for i := len(messages) - 1; i > contentOffset; i-- {
		if messages[i] == "" {
			return i
		}
	}

	return -1
}

// CommandName returns the command name if it was a Request
func (request *RawRequest) CommandName() string {
	defReq, err := NewReq(request.messages)
	if err != nil {
		return ""
	}

	return defReq.CommandName()
}

// RouteParameters returns the parameters if it was a Request
func (request *RawRequest) RouteParameters() key_value.KeyValue {
	defReq, err := NewReq(request.messages)
	if err != nil {
		return key_value.New()
	}

	return defReq.RouteParameters()
}

// ConId returns a connection id for each sending session.
func (request *RawRequest) ConId() string {
	return request.conId
}

func (request *RawRequest) SetConId(conId string) {
	request.conId = conId
}

func (request *RawRequest) Traces() []*Stack {
	return request.trace
}

// IsFirst returns true if the request has no trace,
//
// For example, if the proxy inserts it.
func (request *RawRequest) IsFirst() bool {
	return len(request.trace) == 0
}

// SyncTrace is if the reply has more stacks, the request is updated with it.
// The reply is generated by request.Next().
// Once the request.Next() was used, the reply is returned.
// Update the request with the reply parameters
func (request *RawRequest) SyncTrace(reply ReplyInterface) {
	repTraceLen := len(reply.Traces())
	reqTraceLen := len(request.Traces())

	if repTraceLen > reqTraceLen {
		request.trace = append(request.trace, reply.Traces()[reqTraceLen:]...)
	}
}

// AddRequestStack adds the new trace into the request.
// This method shall be called by the handlers.
// Users should not work with this.
func (request *RawRequest) AddRequestStack(serviceUrl string, serverName string, serverInstance string) {
	stack := &Stack{
		RequestTime:    uint64(time.Now().UnixMicro()),
		ReplyTime:      0,
		Command:        fmt.Sprintf("%d", len(request.trace)+1),
		ServiceUrl:     serviceUrl,
		ServerName:     serverName,
		ServerInstance: serverInstance,
	}

	request.trace = append(request.trace, stack)
}

// ZmqEnvelope the message
func (request *RawRequest) ZmqEnvelope() ([]string, error) {
	preOffset := 1
	if len(request.conId) > 0 {
		preOffset = 2
	}
	postOffset := 0
	if !request.IsFirst() {
		postOffset = 2
	}

	msgLen := len(request.messages)
	if msgLen == 0 {
		msgLen = 1
	}
	messages := make([]string, preOffset+msgLen+postOffset)

	if len(request.conId) > 0 {
		messages[0] = request.conId
		messages[1] = ""
	} else {
		messages[0] = ""
	}

	if len(request.messages) > 0 {
		for i := 0; i < msgLen; i++ {
			messages[i+preOffset] = request.messages[i]
		}
	} else {
		messages[preOffset] = "" // no message
	}

	if len(request.trace) > 0 {
		bytes, err := json.Marshal(request.trace)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize Request to key-value: %v", err)
		}

		str := string(bytes)
		if len(str) == 0 {
			return nil, fmt.Errorf("kv.String is nil")
		}
		messages[preOffset+msgLen] = ""
		messages[preOffset+msgLen+1] = str
	}

	return messages, nil
}

// String the message
func (request *RawRequest) String() string {
	messages, err := request.ZmqEnvelope()
	if err != nil {
		return ""
	}

	contentOffset := 0
	contentEnd := len(messages)

	if len(messages) == 1 {
		return messages[0]
	} else if SyncReplierEnvelope(messages) {
		contentOffset = 1
	} else if MultiPart(messages) {
		contentOffset = 2
	}

	traceIndex := RawTraceIndex(messages)
	if traceIndex > -1 {
		contentEnd = traceIndex
	}

	return JoinMessages(messages[contentOffset:contentEnd])
}

// Bytes convert the message to the sequence of bytes
func (request *RawRequest) Bytes() ([]byte, error) {
	str := request.String()
	if len(str) == 0 {
		return nil, fmt.Errorf("request.String returned an empty string. Try to test it with ZmqEnvelope")
	}

	return []byte(str), nil
}

// SetPublicKey For security; Work in Progress.
func (request *RawRequest) SetPublicKey(publicKey string) {
	request.publicKey = publicKey
}

// PublicKey For security; Work in Progress.
func (request *RawRequest) PublicKey() string {
	return request.publicKey
}

func (request *RawRequest) SetUuid() {
	id := uuid.New()
	request.Uuid = id.String()
}

// Next creates a new request based on the previous one. It uses the Request.
func (request *RawRequest) Next(command string, parameters key_value.KeyValue) {
	nextReq := (&Request{Command: command, Parameters: parameters}).String()

	if len(nextReq) > 0 {
		request.messages = []string{nextReq}
	}
}

// Fail creates a new Reply as a failure
// It accepts the error message that explains the reason of the failure.
func (request *RawRequest) Fail(message string) ReplyInterface {
	defaultReply, _ := (&Reply{Status: FAIL, Message: message, Parameters: key_value.New()}).ZmqEnvelope()

	reply := &RawReply{
		Uuid:     request.Uuid,
		conId:    request.conId,
		messages: defaultReply,
		trace:    request.trace,
	}

	return reply
}

func (request *RawRequest) Ok(parameters key_value.KeyValue) ReplyInterface {
	defaultReply, _ := (&Reply{Status: OK, Message: "", Parameters: parameters}).ZmqEnvelope()

	reply := &RawReply{
		Uuid:     request.Uuid,
		conId:    request.conId,
		messages: defaultReply,
		trace:    request.trace,
	}

	return reply
}

func (request *RawRequest) SetMeta(meta map[string]string) {
	pubKey, ok := meta["pub_key"]
	if ok {
		request.SetPublicKey(pubKey)
	}
}

//
// RawRequest methods
//

func (reply *RawReply) ConId() string {
	return reply.conId
}

func (reply *RawReply) SetConId(conId string) {
	reply.conId = conId
}

func (reply *RawReply) Traces() []*Stack {
	return reply.trace
}

// SetStack adds the current service's server into the reply
func (reply *RawReply) SetStack(serviceUrl string, serverName string, serverInstance string) error {
	for i, stack := range reply.trace {
		if strings.Compare(stack.ServiceUrl, serviceUrl) == 0 &&
			strings.Compare(stack.ServerName, serverName) == 0 &&
			strings.Compare(stack.ServerInstance, serverInstance) == 0 {
			reply.trace[i].ReplyTime = uint64(time.Now().UnixMicro())
			return nil
		}
	}

	return fmt.Errorf("no trace stack for service %s server %s:%s", serviceUrl, serverName, serverInstance)
}

// IsOK is unsupported
func (reply *RawReply) IsOK() bool {
	defRep, err := NewRep(reply.messages)
	if err != nil {
		return false
	}

	return defRep.IsOK()
}

// ReplyParameters returns the parameters if it was a Reply
func (reply *RawReply) ReplyParameters() key_value.KeyValue {
	defRep, err := NewRep(reply.messages)
	if err != nil {
		return nil
	}

	return defRep.ReplyParameters()
}

// ErrorMessage if it was a Reply
func (reply *RawReply) ErrorMessage() string {
	defRep, err := NewRep(reply.messages)
	if err != nil {
		return ""
	}

	return defRep.ErrorMessage()
}

// String the message
func (reply *RawReply) String() string {
	messages, err := reply.ZmqEnvelope()
	if err != nil {
		return ""
	}

	contentOffset := 0
	contentEnd := len(messages)

	if len(messages) == 1 {
		return messages[0]
	} else if SyncReplierEnvelope(messages) {
		contentOffset = 1
	} else if MultiPart(messages) {
		contentOffset = 2
	}

	traceIndex := RawTraceIndex(messages)
	if traceIndex > -1 {
		contentEnd = traceIndex
	}

	return JoinMessages(messages[contentOffset:contentEnd])
}

// ZmqEnvelope the message
func (reply *RawReply) ZmqEnvelope() ([]string, error) {
	preOffset := 1
	if len(reply.conId) > 0 {
		preOffset = 2
	}
	postOffset := 0
	if len(reply.trace) > 0 {
		postOffset = 2
	}

	msgLen := len(reply.messages)
	if msgLen == 0 {
		msgLen = 1
	}
	messages := make([]string, preOffset+msgLen+postOffset)

	if len(reply.conId) > 0 {
		messages[0] = reply.conId
		messages[1] = ""
	} else {
		messages[0] = ""
	}

	if len(reply.messages) > 0 {
		for i := 0; i < msgLen; i++ {
			messages[i+preOffset] = reply.messages[i]
		}
	} else {
		messages[preOffset] = "" // no message
	}

	if len(reply.trace) > 0 {
		bytes, err := json.Marshal(reply.trace)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize Request to key-value: %v", err)
		}

		str := string(bytes)
		if len(str) == 0 {
			return nil, fmt.Errorf("kv.String is nil")
		}
		messages[preOffset+msgLen] = ""
		messages[preOffset+msgLen+1] = str
	}

	return messages, nil
}

// Bytes convert the message to the sequence of bytes
func (reply *RawReply) Bytes() ([]byte, error) {
	str := reply.String()
	if len(str) == 0 {
		return nil, fmt.Errorf("request.String returned an empty string try to test it with calling ZmqEnvelope")
	}

	return []byte(str), nil
}
